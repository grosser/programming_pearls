<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Programming Pearls in Ruby</title>
<link rel="stylesheet" type="text/css" media="all" href="css/reset.css" />
<link rel="stylesheet" type="text/css" media="all" href="css/text.css" />
<link rel="stylesheet" type="text/css" media="all" href="css/ppir.css" />
<link rel="stylesheet" type="text/css" media="print" href="css/print.css" />
</head>
<body>
  <h1>Programming Pearls in Ruby</h1>
<p><span></span></p>

<h1>Chapter 02 1 vector rotation</h1>

<h2>Task</h2>

<ul>
<li>rotate a given vector of length n, m places</li>
<li>rotate without extra memory usage (no copies of the vector)</li>
</ul>


<h2>Solutions</h2>

<p><code>[1,2,3]</code> rotated one place is <code>[2,3,1]</code>.<br/>
Rotation of more than one step at a time is difficult.</p>

<h3>1 * x</h3>

<p>rotate one place, x times</p>

<p><span></span></p>

<pre><code> # lib/02-1-vector-rotation/1.rb

 #helper
 def swap(vector,i,j)
   j %= vector.length
   vector[i], vector[j] = vector[j], vector[i]
 end

 def rotate(vector,steps)
   steps.times {
     (vector.length-1).times {|i| swap(vector,i,i+1)}
   }
   vector
 end
</code></pre>

<h3>re-arrange in a copy</h3>

<p>Making copies is not allowed, but if it where it would be this simple.
Make a copy, and re-arrange inside of it.</p>

<p><span></span></p>

<pre><code> # lib/02-1-vector-rotation/2.rb

 def rotate(vector,steps)
   copy = vector.dup
   vector.each_index do |i|
     vector[i]=copy[(i+steps) % vector.length]
   end
 end
</code></pre>

<h3>juggeling solution</h3>

<p>temp&lt;-1 then 1&lt;-4&lt;-8&lt;-12 then 12&lt;-temp</p>

<p><span></span></p>

<pre><code> # lib/02-1-vector-rotation/3.rb

 require 'rational'
 def rotate(vector,distance)
   length = vector.length
   distance.gcd(length).times do |start|
     temp = vector[start]
     offset = start
     while true do
       swap_with = (offset + distance) % length
       break if swap_with == start
       vector[offset] = vector[swap_with]
       offset = swap_with
     end
     vector[offset] = temp
   end
   vector
 end
</code></pre>

<p><span></span></p>

<h1>Chapter 02 2 anagrams</h1>

<h2>Task</h2>

<ul>
<li>For a given dictionary, find all anagrams and list them</li>
<li>output in lines: <code>eenprsst = presents, serpents</code></li>
</ul>


<h2>Solution</h2>

<p>An anagram for 'no' is 'on', meaning same letters - different order.</p>

<ul>
<li>Store each word in a Hash, where the key are the words sorted letters and the values are all words with the same letters</li>
<li>Remove all keys that only have a single anagram</li>
</ul>


<p><span></span></p>

<pre><code> # lib/02-2-anagrams/1.rb

 anagrams = Hash.new([])
 input.each {|word| anagrams[word.split('').sort] += [word]}
 anagrams.each do |anagram,words|
   words.uniq!
   next if words.size == 1
   puts "#{anagram} = #{words*', '}"
 end
</code></pre>

<p><span></span></p>

<h1>Chapter 04 binary search</h1>

<h2>Task</h2>

<ul>
<li>for a sorted set <code>[1,2,4,5,6]</code> what index has 4 ?</li>
<li>return nil when it is not contained</li>
</ul>


<h2>Solution</h2>

<h3>Simple</h3>

<pre><code>list.index(value)
</code></pre>

<h3>Binary search</h3>

<p>Grab the middle element, if it is to large, continue left of the middel.
If it is to small, continue right of the middel.<br/>
Return nil when no elements are left in the search space.</p>

<p><span></span></p>

<pre><code> # lib/04-binary-search/1.rb

 def binary_find(range,searched)
   middle = range.length/2
   chosen = range[middle]

   return middle if chosen == searched
   return nil if range.length &lt;= 1

   if chosen &lt; searched
     #search in the upper range, add middle to resulting
       ⏎index
     found = binary_find(range[middle..-1],searched)
     if found then middle+found else nil end
   else
     #search in lower range
     binary_find(range[0...middle],searched)
   end
 end
</code></pre>

<h2>Test</h2>

<p><span></span></p>

<pre><code> # lib/04-binary-search/2.rb

 require 'spec'
 describe :binary_find do
   {
     []=&gt;1,
     [1]=&gt;1,
     [1,3]=&gt;3,
     [1,3,4]=&gt;3,
     [1,3,4,6,8,9,12,15,17,20]=&gt;17
   }.each do |range,searched|
     it "find inside #{range.length} element array" do
       binary_find(range,searched).should ==
         ⏎range.index(searched)
     end
     it "returns nil when nothing could be found inside a
       ⏎#{range.length} element array" do
       binary_find(range,2).should == nil
     end
   end
 end
</code></pre>

<p><span></span></p>

<h1>Chapter 07 algorithm design</h1>

<h2>Task</h2>

<p>Find the maximum sum inside a range.<br/>
<code>[1,2,-4,2,4,-3,1]</code> => <code>[2,4]</code> => 6</p>

<h2>Solutions</h2>

<h3>Cubic time O(n³)</h3>

<p>Find the maximum of every possible sub-range.</p>

<p><span></span></p>

<pre><code> # lib/07-algorithm-design/1-cubic.rb

 #runtime O(n³) 2 loops + the sum loop
 def find_max_sum_range(range)
   max = 0
   0.upto(range.length) do |start|
     start.upto(range.length-1) do |end_at|
       max = [range[start..end_at].sum, max].max
     end
   end
   max
 end
</code></pre>

<h3>Quadratic time O(n²)</h3>

<p>Find the maximum of every possible sub-range.<br/>
Do not calculate the sum for every sub-range, rather just add each new element.</p>

<p><code>[1,2,3]</code>: <code>[1]</code> => 1; <code>[1,2]</code> = 1+2 = 3; <code>[1,2,3]</code> = 3+3 = 6</p>

<p><span></span></p>

<pre><code> # lib/07-algorithm-design/2-quadratic.rb

 def find_max_sum_range(range)
   max = 0
   0.upto(range.length) do |start|
     sum=0
     start.upto(range.length-1) do |end_at|
       sum+=range[end_at]
       max = [sum, max].max
     end
   end
   max
 end
</code></pre>

<h3>Less than quadratic time O(n²)</h3>

<p>Find the maximum of every possible sub-range.<br/>
Build sums, where <code>sums[2] == range[0...2].sum</code>
and therefore <code>range[1...3] = sums[1]-sums[3]</code></p>

<p><span></span></p>

<pre><code> # lib/07-algorithm-design/3-quadratic-culmulative.rb

 def find_max_sum_range(range)
   sums=[]
   range.each{|x|sums &lt;&lt; sums.last.to_i+x}

   max = 0
   0.upto(range.length) do |start|
     start.upto(range.length-1) do |end_at|
       start_sum = if start == 0 then 0 else sums[start-1]
         ⏎end# sums[-1] == sums.last
       sum_of_range = sums[end_at]-start_sum
       max = [sum_of_range, max].max
     end
   end
   max
 end
</code></pre>

<h3>Logarithmic time O(n log n)</h3>

<p>Divide the problem into 2 smaller, equal problems. (compare: Binary search)
Maximum of left / right and the maximum of ranges, that cross the middle are comparen.</p>

<p><span></span></p>

<pre><code> # lib/07-algorithm-design/4-logarithmic.rb

 def find_max_sum_range(range)
   #trivial
   return 0 if range.empty?
   return [0,range[0]].max if range.length == 1

   #divide
   middle = range.length / 2
   left = range[0...middle]
   right = range[middle..-1]

   #start from the middel, and build sums to left/right end,
     ⏎to find max, then add them
   middle_max = [left.reverse, right].sum do |sub_range|
     max = sum = 0
     sub_range.each do |value|
       sum+=value
       max = [max,sum].max
     end
     max
   end

   [
     middle_max,
     find_max_sum_range(left),
     find_max_sum_range(right)
   ].max
 end
</code></pre>

<h3>Linear time O(n)</h3>

<p>Compare the sums of all sub-parts. A part ends when its sum drops below 0.</p>

<p><span></span></p>

<pre><code> # lib/07-algorithm-design/5-linear.rb

 def find_max_sum_range(range)
   max = partial_max = 0
   range.each do |x|
     # keep adding to partial max unless it sinks below 0
     partial_max = [partial_max+x, 0].max
     max = [partial_max, max].max
   end
   max
 end
</code></pre>

<p><span></span></p>

<h1>Chapter 13 searching</h1>

<h2>Task</h2>

<ul>
<li>insert randomly generated numbers into a set</li>
<li>insert one-by-one</li>
<li>the set must not contain duplicates after a insertion</li>
<li>return a sorted set, with the requested size, after the last insertion</li>
</ul>


<h2>Solutions</h2>

<h3>1. Hash</h3>

<p>Insert unless key exists, sort at the end</p>

<p><span></span></p>

<pre><code> # lib/13-searching/1-hash.rb

 class SetHash
   def initialize(maximum_value)
     @maximum = maximum_value
   end

   def generate(size)
     raise "size too big" if size &gt;= @maximum #would runs
       ⏎endless
     @set = {}
     while @set.size &lt; size
       random = rand(@maximum)
       @set[random]=true unless @set[random]
     end
     @set.keys.sort
   end
 end
</code></pre>

<h3>2. Array</h3>

<p>Insert unless element is included, sort at the end</p>

<p><span></span></p>

<pre><code> # lib/13-searching/2-naive-array.rb

 class SetArray
   def initialize(maximum_value)
     @maximum = maximum_value
   end

   def generate(size)
     raise "size too big" if size &gt;= @maximum #would runs
       ⏎endless
     @set = []
     while @set.size &lt; size
       random = rand(@maximum)
       @set &lt;&lt; random unless @set.include?(random)
     end
     @set.sort
   end
 end
</code></pre>

<h3>3. Sorted-Linked-List</h3>

<p>A linked list of sorted elements, for easy injection.</p>

<pre><code>@head = {:value=&gt;1,:next=&gt;{:value=&gt;3,:next=&gt;nil}}
</code></pre>

<p>Go thorugh the elements until the insertion position is found.</p>

<p><span></span></p>

<pre><code> # lib/13-searching/3-linked.rb

 class SetLinked
   def initialize(maximum_value)
     @maximum = maximum_value
   end

   def generate(size)
     raise "size too big" if size &gt;= @maximum #would runs
       ⏎endless
     reset
     insert(rand(@maximum)) while @size &lt; size
     flatten
   end

   def reset
     @head = nil
     @size = 0
   end

   def flatten
     flat = []
     link = @head
     while true
       flat &lt;&lt; link[:value]
       break unless link[:next]
       link = link[:next]
     end
     flat
   end

   #insert a number if its new, and update @size counter
   def insert(number)
     return if include?(number)
     @head = insert_link(@head,number)
     @size += 1
   end

   def insert_link(link,number)
     return {:value=&gt;number,:next=&gt;link} if not link or
       ⏎number &lt;= link[:value]
     link[:next] = insert_link(link[:next],number)
     link
   end

   def include?(number)
     link = @head
     while link
       return true if link[:value] == number
       return false if link[:value] &gt; number
       link = link[:next]
     end
     return false
   end
 end
</code></pre>

<p>Using an array (<code>[2,[3,[5,nil]]]</code>) instead of the more-readable <code>hash[:next]</code>, only saves 1/100th of the time.</p>

<h3>4. Sorted Array</h3>

<p>Place elements in a sorted Array, find insertion position using binary-search.</p>

<p><span></span></p>

<pre><code> # lib/13-searching/4-binary-array.rb

 class BinaryArray
   def initialize(maximum_value)
     @maximum = maximum_value
   end

   def generate(size)
     raise "size too big" if size &gt;= @maximum #would runs
       ⏎endless
     @set = []
     while @set.size &lt; size
       random = rand(@maximum)
       found, position = binary_find(random)
       @set.insert(position,random) unless found
     end
     @set
   end

   # search inside the ordered @set
   # return [found,position] where position is where it was
     ⏎found
   # or if not found, where it should be inserted
   def binary_find(value,left=0,right=@set.length-1)
     length_to_search = right+1-left
     middle = left + length_to_search/2

     #found or not found?
     return [true,middle] if @set[middle] == value
     if length_to_search &lt;= 1
       middle += 1 if @set[middle] and @set[middle] &lt; value
       return [false,[middle,0].max]
     end

     #not sure yet, recurse!
     if @set[middle] &gt; value
       binary_find(value,left,middle-1)
     else
       binary_find(value,middle+1,right)
     end
   end
 end
</code></pre>

<h2>Time</h2>

<ol>
<li>O(n) - lookups always take the same time</li>
<li>O(n²) - the longer the array, the longer the lookup takes</li>
<li>O(n²) - the longer the array, 1/2(mean) the longer the lookup takes</li>
<li>n log n - divide and conquer</li>
</ol>


<h2>Performance</h2>

<p>Inserting x items in 2 seconds:
 1.  200_000
 2.  5_000
 3.  ~1_250
 4.  20_000</p>

<h2>Conclusion</h2>

<ul>
<li>nothing beats linear time</li>
<li>when in doubt choose native objects over self-built (2. vs 3.)</li>
<li>when self-built has a lower 'time', investigate performance</li>
</ul>


<p><span></span></p>

<h1>Chapter 14 heaps</h1>

<h2>Task</h2>

<ul>
<li>build and maintain a sorted heap</li>
<li>insert from bottom or top</li>
</ul>


<h2>Solutions</h2>

<p>A heap, where each nodes children are higher then their parent.</p>

<pre><code>      2
   3     4
  5 7  10 12
</code></pre>

<p>Converted to an array, by going from top to bottom and left to right,<br/>
results in <code>[2,3,4,5,7,10,12]</code>.</p>

<h3>Insertion from bottom</h3>

<p>Append to the array and then let the new element flow up (swap with parent)<br/>
until it reaches a parent that is higher than itself.</p>

<p><span></span></p>

<pre><code> # lib/14-heaps/1.rb

 class Heap
   def initialize
     @values = []
   end

   def insert_bottom(value)
     @values &lt;&lt; value
     position = @values.length - 1
     while true
       return if position == root
       return if @values[parent(position)] &lt; value
       swap(position, parent(position))
       position = parent(position)
     end
   end

 private

   def swap(a,b)
     @values[a], @values[b] = @values[b], @values[a]
   end

   def root
     0
   end

   def parent(i)
     (i+1)/2 - 1
   end

   def left_child(i)
     (2*i)+1
   end

   def right_child(i)
     (2*i)+2
   end
 end
</code></pre>

<h3>Insertion from top</h3>

<p>Prepend to the array and then let the new element sink down<br/>
(swap with smallest child) until it reaches a pair of children that<br/>
are lower than itself or a position without any children.</p>

<p><span></span></p>

<pre><code> # lib/14-heaps/2.rb

 class Heap
   def insert_top(value)
     @values.unshift(value)
     position = 0
     while true
       smallest_child = smallest_child(position)
       break if not @values[smallest_child] or
         ⏎@values[smallest_child] &gt;= value
       swap(position, smallest_child)
       position = smallest_child
     end
   end

 protected

   def smallest_child(position)
     left,right = left_child(position),
       ⏎right_child(position)
     return left unless @values[right]
     return right unless @values[left]
     if @values[left] &lt;= @values[right]
       left
     else
       right
     end
   end
 end
</code></pre>

<p><span></span></p>

<h1>Chapter 15 1 count words</h1>

<h2>Task &amp; Solutions</h2>

<h3>Unique words</h3>

<p>Show all words that are inside a given text (unique)!</p>

<p><span></span></p>

<pre><code> # lib/15-1-count-words/1.rb

 puts input.readlines(' ').uniq * "\n"
</code></pre>

<h3>Word counting</h3>

<p>Show all words sorted by number of occurance!</p>

<p>Use a 0-based Hash to mark how often a word has occured.</p>

<p><span></span></p>

<pre><code> # lib/15-1-count-words/2.rb

 occurances = Hash.new(0)
 input.each(' ').each{|word| occurances[word]+=1}
 puts occurances.to_a.sort_by{|word,count|count}.map{|x|x*'
   ⏎times '} * "\n"
</code></pre>

<h3>Benchmarking</h3>

<p>Benchmark occurance counting solution!</p>

<p><span></span></p>

<pre><code> # lib/15-1-count-words/3-1.rb

 occurances = nil

 processing = measure do
   occurances = Hash.new(0)
   input.each(' '){|word| occurances[word]+=1}
 end
 printing = measure do
   puts
     ⏎occurances.to_a.sort_by{|word,count|count}.map{|x|x*'
     ⏎times '} * "\n"
 end
</code></pre>

<h3>Optimization</h3>

<p>Optimize for performance!</p>

<p>Reading the File once and splitting later.</p>

<p><span></span></p>

<pre><code> # lib/15-1-count-words/3-2.rb

 occurances = nil
 processing = measure do
   occurances = Hash.new(0)
   input.read.split(' ').each{|word| occurances[word]+=1}
 end
 printing = measure do
   puts
     ⏎occurances.to_a.sort_by{|word,count|count}.map{|x|x*'
     ⏎times '} * "\n"
 end
</code></pre>

<p>Benchmarking of optimized occurance search<br/>
shows that it is faster (2.5s vs 3.0s for processing)</p>

<p>Memroy usage: ("puts memory" inside the processing loop)</p>

<pre><code>normal:    mapped: 17652K    writeable/private: 2180K    shared: 0K
optimized: mapped: 109892K   writeable/private: 94420K   shared: 0K
</code></pre>

<p>optimized: the text (4.x mb) is in memory twice (once for <code>IO.read</code> and<br/>
once for <code>text.split</code>, no garbage collection was run)</p>

<p><span></span></p>

<h1>Chapter 15 2 duplicate phrases</h1>

<h2>Task</h2>

<p>Find the longest duplicate substring in a text.</p>

<h2>Solutions</h2>

<h3>Simple but slow</h3>

<p>Go through all possible substrings, and see if they are</p>

<ul>
<li>longer than the current longes duplicate substring</li>
<li>occure > 2 times in the text</li>
</ul>


<p>Time: O(n²)</p>

<p><span></span></p>

<pre><code> # lib/15-2-duplicate-phrases/1.rb

 longest = ''
 time = measure do
   0.upto(text.length) do |start|
     start.upto(text.length) do |last|
       substring = text[start..last]
       longest = substring if substring.length &gt;
         ⏎longest.length and text.scan(substring).count ==
         ⏎2
     end
   end
 end
</code></pre>

<h3>Suffix array</h3>

<ul>
<li>Build a suffix-array, where each possible suffix is stored<br/>
abc -> [abc,bc,c]</li>
<li>Sort this array to to move substrings that start with the same letters nearby</li>
<li>find the longest commong prefix 2 neighboring suffixes share<br/>
[a,abc,abd,ac] -> longest duplicate substring is 'ab'</li>
</ul>


<p>Time: O(n)</p>

<p><span></span></p>

<pre><code> # lib/15-2-duplicate-phrases/2.rb

 longest = ''
 time = measure do
   #store each suffix
   suffixes = []
   0.upto(text.length) do |start|
     suffixes &lt;&lt; text[start..text.length]
   end

   #sort them so that equals are next to each other
   suffixes.sort!

   suffixes.each_with_index do |suffix,i|
     common = common_prefix(suffix,suffixes[i+1])
     longest = common if common.length &gt; longest.length
   end
 end
</code></pre>

<p><span></span></p>

<h1>Chapter 15 3 markov</h1>

<h2>Task</h2>

<p>Generate a markov text from given seed data.</p>

<h2>Solution</h2>

<p>Generating random text by truely random placement of letters would be unnatural.</p>

<pre><code>sovudhbyeonnapdubvne
</code></pre>

<p>Every letter in the alphabet has a certain probability to occur after another letter.</p>

<pre><code>l -&gt; l=5% e=10% o=10% i=8% ....
</code></pre>

<p>This yields somewhat natural text</p>

<pre><code>lleno deister
</code></pre>

<p>If we take more than one letter into account, readability inncreases.</p>

<pre><code># markov-4 (4 letters used when calculating propability)
"Hell" -&gt; o = 80%, ' '=20%
</code></pre>

<p>The more letters we take into account, the more natural the generated words sound.<br/>
What we can do with letters, we can do with whole words!</p>

<ul>
<li>calculate the probability word A follows on word B, using seed data</li>
<li>generate random text</li>
</ul>


<p><span></span></p>

<pre><code> # lib/15-3-markov/1.rb

 #build possible_successors for any used word
 possible_successors = Hash.new([])
 0.upto(text.length-1) do |i|
   possible_successors[text[i]] &lt;&lt; text[i+1]
 end

 #build text by randomly adding possible_successors
 random_text = [text.first]
 0.upto(50).map do |i|
   random_text &lt;&lt; possible_successors[random_text.last].rand
 end

 puts random_text * ' '
</code></pre>

</body>
