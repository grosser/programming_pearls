<h1>Chapter 02 1 vector rotation</h1>

<ul>
<li><code>[1,2,3]</code> rotated one place is <code>[2,3,1]</code></li>
<li>Rotation of more than one step at a time is difficult</li>
</ul>


<h2>Task</h2>

<p>Rotate a given vector of length n, m places</p>

<h2>Constraints</h2>

<ul>
<li>rotate without extra memory usage (no copies of the vector)</li>
</ul>


<h2>Solutions</h2>

<h3>1 * x</h3>

<p>rotate one place, x times
<span></span></p>

<pre><code># lib/02-1-vector-rotation/1.rb

#helper
def swap(vector,i,j)
  j %= vector.length
  vector[i], vector[j] = vector[j], vector[i]
end

def rotate(vector,steps)
  steps.times {
    (vector.length-1).times {|i| swap(vector,i,i+1)}
  }
  vector
end
</code></pre>

<h3>re-arrange in a copy</h3>

<p>Making copies is not allowed, but if it where it would be this simple.
Make a copy, and re-arrange inside of it.
<span></span></p>

<pre><code># lib/02-1-vector-rotation/2.rb

def rotate(vector,steps)
  copy = vector.dup
  vector.each_index do |i|
    vector[i]=copy[(i+steps) % vector.length]
  end
end
</code></pre>

<h3>juggeling solution</h3>

<p>temp&lt;-1 then 1&lt;-4&lt;-8&lt;-12 then 12&lt;-temp
<span></span></p>

<pre><code># lib/02-1-vector-rotation/3.rb

require 'rational'
def rotate(vector,distance)
  length = vector.length
  distance.gcd(length).times do |start|
    temp = vector[start]
    offset = start
    while true do
      swap_with = (offset + distance) % length
      break if swap_with == start
      vector[offset] = vector[swap_with]
      offset = swap_with
    end
    vector[offset] = temp
  end
  vector
end
</code></pre>

<h1>Chapter 02 2 anagrams</h1>

<p>An anagram for 'no' is 'on', meaning same letters - different order.</p>

<h2>Task</h2>

<ul>
<li>For a given dictionary, find all anagrams and list them</li>
<li>output in lines: <code>eenprsst = presents, serpents</code></li>
</ul>


<h2>Solution</h2>

<ul>
<li>Store each word in a hash, where the key are the words sorted letters and the values are all words with the same letters</li>
<li>Remove all keys that only have a single anagram</li>
</ul>


<p><span></span></p>

<pre><code># lib/02-2-anagrams/1.rb

anagrams = Hash.new([])
input.each {|word| anagrams[word.split('').sort] += [word]}
anagrams.each do |anagram,words|
  words.uniq!
  next if words.size == 1
  puts "#{anagram} = #{words*', '}"
end
</code></pre>

<h1>Chapter 04 binary search</h1>

<h2>Task</h2>

<ul>
<li>for a sorted set <code>[1,2,4,5,6]</code> what index has 4 ?</li>
<li>return nil when it is not contained</li>
</ul>


<h2>Solution</h2>

<h3>Simple</h3>

<pre><code>list.index(value)
</code></pre>

<h3>Binary search</h3>

<p>Grab the middle element, if it is to large, continue left of the middel.
If it is to small, continue right of the middel.<br/>
Return nil when no elements are left in the search space.</p>

<p><span></span></p>

<pre><code># lib/04-binary-search/1.rb

def binary_find(range,searched)
  middle = range.length/2
  chosen = range[middle]

  return middle if chosen == searched
  return nil if range.length &lt;= 1

  if chosen &lt; searched
    #search in the upper range, add middle to resulting index
    found = binary_find(range[middle..-1],searched)
    if found then middle+found else nil end
  else
    #search in lower range
    binary_find(range[0...middle],searched)
  end
end
</code></pre>

<h2>Test</h2>

<p><span></span></p>

<pre><code># lib/04-binary-search/2.rb

require 'spec'
describe :binary_find do
  {
    []=&gt;1,
    [1]=&gt;1,
    [1,3]=&gt;3,
    [1,3,4]=&gt;3,
    [1,3,4,6,8,9,12,15,17,20]=&gt;17
  }.each do |range,searched|
    it "find inside #{range.length} element array" do
      binary_find(range,searched).should == range.index(searched)
    end
    it "returns nil when nothing could be found inside a #{range.length} element array" do
      binary_find(range,2).should == nil
    end
  end
end
</code></pre>

<h1>Chapter 07 algorithm design</h1>

<h2>Task</h2>

<p>Find the maximum sum inside a range.<br/>
<code>[1,2,-4,2,4,-3,1]</code> => <code>[2,4]</code> => 6</p>

<h2>Solutions</h2>

<h3>Cubic time O(n³)</h3>

<p>Find the maximum of every possible sub-range.</p>

<p><span></span></p>

<pre><code># lib/07-algorithm-design/1-cubic.rb

#runtime O(n³) 2 loops + the sum loop
def find_max_sum_range(range)
  max = 0
  0.upto(range.length) do |start|
    start.upto(range.length-1) do |end_at|
      max = [range[start..end_at].sum, max].max
    end
  end
  max
end
</code></pre>

<h3>Quadratic time O(n²)</h3>

<p>Find the maximum of every possible sub-range.<br/>
Do not calculate the sum for every sub-range, rather just add each new element.</p>

<p><code>[1,2,3]</code>: <code>[1]</code> => 1; <code>[1,2]</code> = 1+2 = 3; <code>[1,2,3]</code> = 3+3 = 6</p>

<p><span></span></p>

<pre><code># lib/07-algorithm-design/2-quadratic.rb

def find_max_sum_range(range)
  max = 0
  0.upto(range.length) do |start|
    sum=0
    start.upto(range.length-1) do |end_at|
      sum+=range[end_at]
      max = [sum, max].max
    end
  end
  max
end
</code></pre>

<h3>Less than quadratic time O(n²)</h3>

<p>Find the maximum of every possible sub-range.<br/>
Build sums, where <code>sums[2] == range[0...2].sum</code>
and therefore <code>range[1...3] = sums[1]-sums[3]</code></p>

<p><span></span></p>

<pre><code># lib/07-algorithm-design/3-quadratic-culmulative.rb

def find_max_sum_range(range)
  sums=[]
  range.each{|x|sums &lt;&lt; sums.last.to_i+x}

  max = 0
  0.upto(range.length) do |start|
    start.upto(range.length-1) do |end_at|
      start_sum = if start == 0 then 0 else sums[start-1] end# sums[-1] == sums.last
      sum_of_range = sums[end_at]-start_sum
      max = [sum_of_range, max].max
    end
  end
  max
end
</code></pre>

<h3>Logarithmic time O(n log n)</h3>

<p>Divide the problem into 2 smaller, equal problems. (compare: Binary search)
Maximum of left / right and the maximum of ranges, that cross the middle are comparen.</p>

<p><span></span></p>

<pre><code># lib/07-algorithm-design/4-logarithmic.rb

def find_max_sum_range(range)
  #trivial
  return 0 if range.empty?
  return [0,range[0]].max if range.length == 1

  #divide
  middle = range.length / 2
  left = range[0...middle]
  right = range[middle..-1]

  #start from the middel, and build sums to left/right end, to find max, then add them
  middle_max = [left.reverse, right].sum do |sub_range|
    max = sum = 0
    sub_range.each do |value|
      sum+=value
      max = [max,sum].max
    end
    max
  end

  [
    middle_max,
    find_max_sum_range(left),
    find_max_sum_range(right)
  ].max
end
</code></pre>

<h3>Linear time O(n)</h3>

<p>Compare the sums of all sub-parts. A part ends when its sum drops below 0.
<span></span></p>

<pre><code># lib/07-algorithm-design/5-linear.rb

def find_max_sum_range(range)
  max = partial_max = 0
  range.each do |x|
    # keep adding to partial max unless it sinks below 0
    partial_max = [partial_max+x, 0].max
    max = [partial_max, max].max
  end
  max
end
</code></pre>

<h1>Chapter 13 searching</h1>

<h1>Chapter 14 heaps</h1>

<h1>Chapter 15 1 count words</h1>

<h1>Chapter 15 2 duplicate phrases</h1>

<h1>Chapter 15 3 markov</h1>
