<h1>Chapter 02 1 vector rotation</h1>

<ul>
<li><code>[1,2,3]</code> rotated one place is <code>[2,3,1]</code></li>
<li>Rotation of more than one step at a time is difficult</li>
</ul>


<h2>Task</h2>

<p>Rotate a given vector of length n, m places</p>

<h2>Constraints</h2>

<ul>
<li>rotate without extra memory usage (no copies of the vector)</li>
</ul>


<h2>Solutions</h2>

<h3>1 * x</h3>

<p>rotate one place, x times
<span></span></p>

<pre><code># lib/02-1-vector-rotation/1.rb

#helper
def swap(vector,i,j)
  j %= vector.length
  vector[i], vector[j] = vector[j], vector[i]
end

def rotate(vector,steps)
  steps.times {
    (vector.length-1).times {|i| swap(vector,i,i+1)}
  }
  vector
end
</code></pre>

<h3>re-arrange in a copy</h3>

<p>Making copies is not allowed, but if it where it would be this simple.
Make a copy, and re-arrange inside of it.
<span></span></p>

<pre><code># lib/02-1-vector-rotation/2.rb

def rotate(vector,steps)
  copy = vector.dup
  vector.each_index do |i|
    vector[i]=copy[(i+steps) % vector.length]
  end
end
</code></pre>

<h3>juggeling solution</h3>

<p>temp&lt;-1 then 1&lt;-4&lt;-8&lt;-12 then 12&lt;-temp
<span></span></p>

<pre><code># lib/02-1-vector-rotation/3.rb

require 'rational'
def rotate(vector,distance)
  length = vector.length
  distance.gcd(length).times do |start|
    temp = vector[start]
    offset = start
    while true do
      swap_with = (offset + distance) % length
      break if swap_with == start
      vector[offset] = vector[swap_with]
      offset = swap_with
    end
    vector[offset] = temp
  end
  vector
end
</code></pre>

<h1>Chapter 02 2 anagrams</h1>

<p>An anagram for 'no' is 'on', meaning same letters - different order.</p>

<h2>Task</h2>

<ul>
<li>For a given dictionary, find all anagrams and list them</li>
<li>output in lines: <code>eenprsst = presents, serpents</code></li>
</ul>


<h2>Solution</h2>

<ul>
<li>Store each word in a hash, where the key are the words sorted letters and the values are all words with the same letters</li>
<li>Remove all keys that only have a single anagram</li>
</ul>


<p><span></span></p>

<pre><code># lib/02-2-anagrams/1.rb

anagrams = Hash.new([])
input.each {|word| anagrams[word.split('').sort] += [word]}
anagrams.each do |anagram,words|
  words.uniq!
  next if words.size == 1
  puts "#{anagram} = #{words*', '}"
end
</code></pre>

<h1>Chapter 04 binary search</h1>

<h2>Task</h2>

<ul>
<li>for a sorted set <code>[1,2,4,5,6]</code> what index has 4 ?</li>
<li>return nil when it is not contained</li>
</ul>


<h2>Solution</h2>

<h3>Simple</h3>

<pre><code>list.index(value)
</code></pre>

<h3>Binary search</h3>

<p>Grab the middle element, if it is to large, continue left of the middel.
If it is to small, continue right of the middel.<br/>
Return nil when no elements are left in the search space.</p>

<p><span></span></p>

<pre><code># lib/04-binary-search/1.rb

def binary_find(range,searched)
  middle = range.length/2
  chosen = range[middle]

  return middle if chosen == searched
  return nil if range.length &lt;= 1

  if chosen &lt; searched
    #search in the upper range, add middle to resulting index
    found = binary_find(range[middle..-1],searched)
    if found then middle+found else nil end
  else
    #search in lower range
    binary_find(range[0...middle],searched)
  end
end
</code></pre>

<h2>Test</h2>

<p><span></span></p>

<pre><code># lib/04-binary-search/2.rb

require 'spec'
describe :binary_find do
  {
    []=&gt;1,
    [1]=&gt;1,
    [1,3]=&gt;3,
    [1,3,4]=&gt;3,
    [1,3,4,6,8,9,12,15,17,20]=&gt;17
  }.each do |range,searched|
    it "find inside #{range.length} element array" do
      binary_find(range,searched).should == range.index(searched)
    end
    it "returns nil when nothing could be found inside a #{range.length} element array" do
      binary_find(range,2).should == nil
    end
  end
end
</code></pre>

<h1>Chapter 07 algorithm design</h1>

<h1>Chapter 13 searching</h1>

<h1>Chapter 14 heaps</h1>

<h1>Chapter 15 1 count words</h1>

<h1>Chapter 15 2 duplicate phrases</h1>

<h1>Chapter 15 3 markov</h1>
